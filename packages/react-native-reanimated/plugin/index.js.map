{
  "version": 3,
  "sources": ["src/types.ts", "src/globals.ts", "src/utils.ts", "src/workletStringCode.ts", "src/workletFactory.ts", "src/workletFactoryCall.ts", "src/workletSubstitution.ts", "src/gestureHandlerAutoworkletization.ts", "src/layoutAnimationAutoworkletization.ts", "src/referencedWorklets.ts", "src/objectWorklets.ts", "src/autoworkletization.ts", "src/contextObject.ts", "src/file.ts", "src/inlineStylesWarning.ts", "src/webOptimization.ts", "src/class.ts", "src/plugin.ts"],
  "sourcesContent": ["import type { BabelFile, NodePath } from '@babel/core';\nimport type {\n  ArrowFunctionExpression,\n  Node as BabelNode,\n  FunctionDeclaration,\n  FunctionExpression,\n  ObjectExpression,\n  ObjectMethod,\n} from '@babel/types';\nimport {\n  isArrowFunctionExpression,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isObjectExpression,\n  isObjectMethod,\n} from '@babel/types';\n\nexport interface ReanimatedPluginOptions {\n  relativeSourceLocation?: boolean;\n  disableInlineStylesWarning?: boolean;\n  processNestedWorklets?: boolean;\n  omitNativeOnlyData?: boolean;\n  globals?: string[];\n  substituteWebPlatformChecks?: boolean;\n  disableSourceMaps?: boolean;\n}\n\nexport interface ReanimatedPluginPass {\n  file: BabelFile;\n  key: string;\n  opts: ReanimatedPluginOptions;\n  cwd: string;\n  filename: string | undefined;\n  get(key: unknown): unknown;\n  set(key: unknown, value: unknown): void;\n  workletNumber: number;\n  [key: string]: unknown;\n}\n\nexport type WorkletizableFunction =\n  | FunctionDeclaration\n  | FunctionExpression\n  | ArrowFunctionExpression\n  | ObjectMethod;\n\nexport const WorkletizableFunction =\n  'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod';\n\nexport type WorkletizableObject = ObjectExpression;\n\nexport const WorkletizableObject = 'ObjectExpression';\n\nexport function isWorkletizableFunctionPath(\n  path: NodePath<unknown>\n): path is NodePath<WorkletizableFunction> {\n  return (\n    path.isFunctionDeclaration() ||\n    path.isFunctionExpression() ||\n    path.isArrowFunctionExpression() ||\n    path.isObjectMethod()\n  );\n}\n\nexport function isWorkletizableFunctionNode(\n  node: BabelNode | null | undefined\n): node is WorkletizableFunction {\n  return (\n    isFunctionDeclaration(node) ||\n    isFunctionExpression(node) ||\n    isArrowFunctionExpression(node) ||\n    isObjectMethod(node)\n  );\n}\n\nexport function isWorkletizableObjectPath(\n  path: NodePath<unknown>\n): path is NodePath<WorkletizableObject> {\n  return path.isObjectExpression();\n}\n\nexport function isWorkletizableObjectNode(\n  node: BabelNode | null | undefined\n): node is WorkletizableObject {\n  return isObjectExpression(node);\n}\n\nexport const workletClassFactorySuffix = '__classFactory';\n", "const notCapturedIdentifiers = [\n  // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n\n  // Note that objects' properties don't need to be listed since we always only capture the whole object,\n  // e.g. `global.__ErrorUtils` or `Intl.DateTimeFormat`.\n\n  // Value properties\n  'globalThis',\n  'Infinity',\n  'NaN',\n  'undefined',\n\n  // Function properties\n  'eval',\n  'isFinite',\n  'isNaN',\n  'parseFloat',\n  'parseInt',\n  'decodeURI',\n  'decodeURIComponent',\n  'encodeURI',\n  'encodeURIComponent',\n  'escape',\n  'unescape',\n\n  // Fundamental objects\n  'Object',\n  'Function',\n  'Boolean',\n  'Symbol',\n\n  // Error objects\n  'Error',\n  'AggregateError',\n  'EvalError',\n  'RangeError',\n  'ReferenceError',\n  'SyntaxError',\n  'TypeError',\n  'URIError',\n  'InternalError',\n\n  // Numbers and dates\n  'Number',\n  'BigInt',\n  'Math',\n  'Date',\n\n  // Text processing\n  'String',\n  'RegExp',\n\n  // Indexed collections\n  'Array',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'BigInt64Array',\n  'BigUint64Array',\n  'Float32Array',\n  'Float64Array',\n\n  // Keyed collections\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n\n  // Structured data\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Atomics',\n  'JSON',\n\n  // Managing memory\n  'WeakRef',\n  'FinalizationRegistry',\n\n  // Control abstraction objects\n  'Iterator',\n  'AsyncIterator',\n  'Promise',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'Generator',\n  'AsyncGenerator',\n  'AsyncFunction',\n\n  // Reflection\n  'Reflect',\n  'Proxy',\n\n  // Internationalization\n  'Intl',\n\n  // Other stuff\n  'null',\n  'this',\n  'global',\n  'window',\n  'globalThis',\n  'console',\n  'performance',\n  'queueMicrotask',\n  'requestAnimationFrame',\n  'setImmediate',\n  'arguments', // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n\n  // Hermes\n  'HermesInternal',\n\n  // Reanimated\n  '_WORKLET',\n  'ReanimatedError',\n  '__reanimatedLoggerConfig',\n\n  // Classes\n  '_createSuper',\n  '_callSuper',\n  '_possibleConstructorReturn',\n  '_assertThisInitialized',\n  '_isNativeReflectConstruct',\n  '_getPrototypeOf',\n  '_inherits',\n  '_setPrototypeOf',\n  '_typeof',\n  '_classCallCheck',\n  '_defineProperties',\n  '_defineProperty',\n  '_createClass',\n  '_toPropertyKey',\n  '_toPrimitive',\n  '_superPropBase',\n  '_get',\n];\n\n/**\n * @deprecated Since we moved on to using `global.` prefix in Reanimated, we\n *   don't need to capture these identifiers anymore. However, for safety\n *   reasons and 3rd party libraries, we still keep them in the list.\n *\n *   `_WORKLET` is the only exception since it's a part of the public API.\n */\n// eslint-disable-next-line camelcase\nconst notCapturedIdentifiers_DEPRECATED = [\n  // Reanimated\n  '_IS_FABRIC',\n  '_log',\n  '_toString',\n  '_scheduleHostFunctionOnJS',\n  '_scheduleRemoteFunctionOnJS',\n  '_scheduleOnRuntime',\n  '_makeShareableClone',\n  '_updatePropsPaper',\n  '_updatePropsFabric',\n  '_removeFromPropsRegistry',\n  '_measurePaper',\n  '_measureFabric',\n  '_scrollToPaper',\n  '_dispatchCommandPaper',\n  '_dispatchCommandFabric',\n  '_setGestureState',\n  '_notifyAboutProgress',\n  '_notifyAboutEnd',\n  '_runOnUIQueue',\n  '_getAnimationTimestamp',\n];\n\nexport const defaultGlobals = new Set(\n  notCapturedIdentifiers.concat(notCapturedIdentifiers_DEPRECATED)\n);\n\nexport let globals: Set<string>;\n\nexport function initializeGlobals() {\n  globals = new Set(defaultGlobals);\n}\n", "import type { NodePath } from '@babel/traverse';\nimport type { CallExpression } from '@babel/types';\nimport {\n  identifier,\n  isExportNamedDeclaration,\n  isScopable,\n  variableDeclaration,\n  variableDeclarator,\n} from '@babel/types';\nimport { globals } from './globals';\nimport type { ReanimatedPluginPass } from './types';\n\nexport function isRelease() {\n  const pattern = /(prod|release|stag[ei])/i;\n  return !!(\n    process.env.BABEL_ENV?.match(pattern) ||\n    process.env.NODE_ENV?.match(pattern)\n  );\n}\n\n/**\n * This function allows to add custom globals such as host-functions. Those\n * globals have to be passed as an argument for the plugin in babel.config.js.\n *\n * For example:\n *\n * ```js\n * plugins: [\n *   ['react-native-reanimated/plugin', { globals: ['myHostFunction'] }],\n * ];\n * ```\n */\nexport function addCustomGlobals(this: ReanimatedPluginPass) {\n  if (this.opts && Array.isArray(this.opts.globals)) {\n    this.opts.globals.forEach((name: string) => {\n      globals.add(name);\n    });\n  }\n}\n\n/**\n * This function replaces the node with a factory call while making sure that\n * it's a legal operation. If the node cannot be simply replaced with a factory\n * call, it will be replaced with a variable declaration.\n *\n * For example:\n *\n * ```ts\n * const foo = function () {\n *   'worklet';\n *   return 1;\n * };\n * ```\n *\n * Becomes\n *\n * ```ts\n * const foo = factoryCall();\n * ```\n *\n * But:\n *\n * ```ts\n * export function foo() {\n *   'worklet';\n *   return 1;\n * }\n * ```\n *\n * Becomes\n *\n * ```ts\n * export const foo = factoryCall();\n * ```\n */\nexport function replaceWithFactoryCall(\n  toReplace: NodePath<unknown>,\n  name: string | undefined,\n  factoryCall: CallExpression\n) {\n  if (!name || !needsDeclaration(toReplace)) {\n    toReplace.replaceWith(factoryCall);\n  } else {\n    const replacement = variableDeclaration('const', [\n      variableDeclarator(identifier(name), factoryCall),\n    ]);\n    toReplace.replaceWith(replacement);\n  }\n}\n\nfunction needsDeclaration(nodePath: NodePath<unknown>): boolean {\n  return (\n    isScopable(nodePath.parent) || isExportNamedDeclaration(nodePath.parent)\n  );\n}\n", "import type { BabelFileResult, NodePath, PluginItem } from '@babel/core';\nimport { transformSync, traverse } from '@babel/core';\nimport generate from '@babel/generator';\nimport type {\n  File as BabelFile,\n  ExpressionStatement,\n  FunctionDeclaration,\n  Identifier,\n  VariableDeclaration,\n} from '@babel/types';\nimport {\n  assertBlockStatement,\n  callExpression,\n  functionExpression,\n  identifier,\n  isArrowFunctionExpression,\n  isBlockStatement,\n  isExpression,\n  isExpressionStatement,\n  isFunctionDeclaration,\n  isIdentifier,\n  isObjectMethod,\n  isProgram,\n  memberExpression,\n  objectPattern,\n  objectProperty,\n  thisExpression,\n  variableDeclaration,\n  variableDeclarator,\n} from '@babel/types';\nimport { strict as assert } from 'assert';\nimport * as convertSourceMap from 'convert-source-map';\nimport * as fs from 'fs';\nimport type { ReanimatedPluginPass, WorkletizableFunction } from './types';\nimport { workletClassFactorySuffix } from './types';\nimport { isRelease } from './utils';\n\nconst MOCK_SOURCE_MAP = 'mock source map';\n\nexport function buildWorkletString(\n  fun: BabelFile,\n  state: ReanimatedPluginPass,\n  closureVariables: Array<Identifier>,\n  workletName: string,\n  inputMap: BabelFileResult['map']\n): Array<string | null | undefined> {\n  restoreRecursiveCalls(fun, workletName);\n\n  const draftExpression = (fun.program.body.find((obj) =>\n    isFunctionDeclaration(obj)\n  ) ||\n    fun.program.body.find((obj) => isExpressionStatement(obj)) ||\n    undefined) as FunctionDeclaration | ExpressionStatement | undefined;\n\n  assert(draftExpression, '[Reanimated] `draftExpression` is undefined.');\n\n  const expression = isFunctionDeclaration(draftExpression)\n    ? draftExpression\n    : draftExpression.expression;\n\n  assert(\n    'params' in expression,\n    \"'params' property is undefined in 'expression'\"\n  );\n  assert(\n    isBlockStatement(expression.body),\n    '[Reanimated] `expression.body` is not a `BlockStatement`'\n  );\n\n  const parsedClasses = new Set<string>();\n\n  traverse(fun, {\n    NewExpression(path) {\n      if (!isIdentifier(path.node.callee)) {\n        return;\n      }\n      const constructorName = path.node.callee.name;\n      if (\n        !closureVariables.some(\n          (variable) => variable.name === constructorName\n        ) ||\n        parsedClasses.has(constructorName)\n      ) {\n        return;\n      }\n      const index = closureVariables.findIndex(\n        (variable) => variable.name === constructorName\n      );\n      closureVariables.splice(index, 1);\n      const workletClassFactoryName =\n        constructorName + workletClassFactorySuffix;\n      closureVariables.push(identifier(workletClassFactoryName));\n\n      assertBlockStatement(expression.body);\n      expression.body.body.unshift(\n        variableDeclaration('const', [\n          variableDeclarator(\n            identifier(constructorName),\n            callExpression(identifier(workletClassFactoryName), [])\n          ),\n        ])\n      );\n      parsedClasses.add(constructorName);\n    },\n  });\n\n  const workletFunction = functionExpression(\n    identifier(workletName),\n    expression.params,\n    expression.body,\n    expression.generator,\n    expression.async\n  );\n\n  const code = generate(workletFunction).code;\n\n  assert(inputMap, '[Reanimated] `inputMap` is undefined.');\n\n  const includeSourceMap = !(isRelease() || state.opts.disableSourceMaps);\n\n  if (includeSourceMap) {\n    // Clear contents array (should be empty anyways)\n    inputMap.sourcesContent = [];\n    // Include source contents in source map, because Flipper/iframe is not\n    // allowed to read files from disk.\n    for (const sourceFile of inputMap.sources) {\n      inputMap.sourcesContent.push(\n        fs.readFileSync(sourceFile).toString('utf-8')\n      );\n    }\n  }\n\n  const transformed = transformSync(code, {\n    plugins: [\n      prependClosureVariablesIfNecessary(closureVariables),\n      '@babel/plugin-transform-class-properties',\n      '@babel/plugin-transform-classes',\n    ],\n    compact: true,\n    sourceMaps: includeSourceMap,\n    inputSourceMap: inputMap,\n    ast: false,\n    babelrc: false,\n    configFile: false,\n    comments: false,\n  });\n\n  assert(transformed, '[Reanimated] `transformed` is null.');\n\n  if (transformed.code) {\n    const index = transformed.code.indexOf(`function ${workletName}`);\n    transformed.code = transformed.code.slice(index);\n  }\n  let sourceMap;\n  if (includeSourceMap) {\n    if (shouldMockSourceMap()) {\n      sourceMap = MOCK_SOURCE_MAP;\n    } else {\n      sourceMap = convertSourceMap.fromObject(transformed.map).toObject();\n      // sourcesContent field contains a full source code of the file which contains the worklet\n      // and is not needed by the source map interpreter in order to symbolicate a stack trace.\n      // Therefore, we remove it to reduce the bandwith and avoid sending it potentially multiple times\n      // in files that contain multiple worklets. Along with sourcesContent.\n      delete sourceMap.sourcesContent;\n    }\n  }\n\n  return [transformed.code, JSON.stringify(sourceMap)];\n}\n\n/**\n * Function that restores recursive calls after the name of the worklet has\n * changed.\n */\nfunction restoreRecursiveCalls(file: BabelFile, newName: string): void {\n  traverse(file, {\n    FunctionExpression(path) {\n      if (!path.node.id) {\n        // Function wasn't named, hence it couldn't have had recursive calls by its name.\n        path.stop();\n        return;\n      }\n      const oldName = path.node.id.name;\n      const scope = path.scope;\n      scope.rename(oldName, newName);\n    },\n  });\n}\n\nfunction shouldMockSourceMap() {\n  // We don't want to pollute tests with source maps so we mock it\n  // for all tests (except one)\n  return process.env.REANIMATED_JEST_SHOULD_MOCK_SOURCE_MAP === '1';\n}\n\nfunction prependClosure(\n  path: NodePath<WorkletizableFunction>,\n  closureVariables: Array<Identifier>,\n  closureDeclaration: VariableDeclaration\n) {\n  if (closureVariables.length === 0 || !isProgram(path.parent)) {\n    return;\n  }\n\n  if (!isExpression(path.node.body)) {\n    path.node.body.body.unshift(closureDeclaration);\n  }\n}\n\nfunction prependRecursiveDeclaration(path: NodePath<WorkletizableFunction>) {\n  if (\n    isProgram(path.parent) &&\n    !isArrowFunctionExpression(path.node) &&\n    !isObjectMethod(path.node) &&\n    path.node.id &&\n    path.scope.parent\n  ) {\n    const hasRecursiveCalls =\n      path.scope.parent.bindings[path.node.id.name]?.references > 0;\n    if (hasRecursiveCalls) {\n      path.node.body.body.unshift(\n        variableDeclaration('const', [\n          variableDeclarator(\n            identifier(path.node.id.name),\n            memberExpression(thisExpression(), identifier('_recur'))\n          ),\n        ])\n      );\n    }\n  }\n}\n\nfunction prependClosureVariablesIfNecessary(\n  closureVariables: Array<Identifier>\n): PluginItem {\n  const closureDeclaration = variableDeclaration('const', [\n    variableDeclarator(\n      objectPattern(\n        closureVariables.map((variable) =>\n          objectProperty(\n            identifier(variable.name),\n            identifier(variable.name),\n            false,\n            true\n          )\n        )\n      ),\n      memberExpression(thisExpression(), identifier('__closure'))\n    ),\n  ]);\n\n  return {\n    visitor: {\n      'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ObjectMethod':\n        (path: NodePath<WorkletizableFunction>) => {\n          prependClosure(path, closureVariables, closureDeclaration);\n          prependRecursiveDeclaration(path);\n        },\n    },\n  };\n}\n", "/* eslint-disable @typescript-eslint/no-var-requires */\nimport type { NodePath } from '@babel/core';\nimport { transformSync, traverse } from '@babel/core';\nimport generate from '@babel/generator';\nimport type {\n  File as BabelFile,\n  ExpressionStatement,\n  FunctionExpression,\n  Identifier,\n  ReturnStatement,\n  VariableDeclaration,\n} from '@babel/types';\nimport {\n  arrayExpression,\n  assignmentExpression,\n  blockStatement,\n  cloneNode,\n  expressionStatement,\n  functionExpression,\n  identifier,\n  isBlockStatement,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isIdentifier,\n  isMemberExpression,\n  isObjectExpression,\n  isObjectMethod,\n  isObjectProperty,\n  memberExpression,\n  newExpression,\n  numericLiteral,\n  objectExpression,\n  objectProperty,\n  returnStatement,\n  stringLiteral,\n  toIdentifier,\n  variableDeclaration,\n  variableDeclarator,\n} from '@babel/types';\nimport { strict as assert } from 'assert';\nimport { basename, relative } from 'path';\nimport { globals } from './globals';\nimport type { ReanimatedPluginPass, WorkletizableFunction } from './types';\nimport { workletClassFactorySuffix } from './types';\nimport { isRelease } from './utils';\nimport { buildWorkletString } from './workletStringCode';\n\nconst REAL_VERSION = require('../../package.json').version;\nconst MOCK_VERSION = 'x.y.z';\n\nconst workletStringTransformPresets = [\n  require.resolve('@babel/preset-typescript'),\n];\n\nconst workletStringTransformPlugins = [\n  require.resolve('@babel/plugin-transform-shorthand-properties'),\n  require.resolve('@babel/plugin-transform-arrow-functions'),\n  require.resolve('@babel/plugin-transform-optional-chaining'),\n  require.resolve('@babel/plugin-transform-nullish-coalescing-operator'),\n  [\n    require.resolve('@babel/plugin-transform-template-literals'),\n    { loose: true },\n  ],\n];\n\nexport function makeWorkletFactory(\n  fun: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): FunctionExpression {\n  // Returns a new FunctionExpression which is a workletized version of provided\n  // FunctionDeclaration, FunctionExpression, ArrowFunctionExpression or ObjectMethod.\n\n  removeWorkletDirective(fun);\n\n  // We use copy because some of the plugins don't update bindings and\n  // some even break them\n  assert(\n    state.file.opts.filename,\n    '[Reanimated] `state.file.opts.filename` is undefined.'\n  );\n\n  const codeObject = generate(fun.node, {\n    sourceMaps: true,\n    sourceFileName: state.file.opts.filename,\n  });\n\n  // We need to add a newline at the end, because there could potentially be a\n  // comment after the function that gets included here, and then the closing\n  // bracket would become part of the comment thus resulting in an error, since\n  // there is a missing closing bracket.\n  codeObject.code =\n    '(' + (fun.isObjectMethod() ? 'function ' : '') + codeObject.code + '\\n)';\n\n  const transformed = transformSync(codeObject.code, {\n    filename: state.file.opts.filename,\n    presets: workletStringTransformPresets,\n    plugins: workletStringTransformPlugins,\n    ast: true,\n    babelrc: false,\n    configFile: false,\n    inputSourceMap: codeObject.map,\n  });\n\n  assert(transformed, '[Reanimated] `transformed` is undefined.');\n  assert(transformed.ast, '[Reanimated] `transformed.ast` is undefined.');\n\n  const variables = makeArrayFromCapturedBindings(transformed.ast, fun);\n\n  const clone = cloneNode(fun.node);\n  const funExpression = isBlockStatement(clone.body)\n    ? functionExpression(\n        null,\n        clone.params,\n        clone.body,\n        clone.generator,\n        clone.async\n      )\n    : clone;\n\n  const { workletName, reactName } = makeWorkletName(fun, state);\n\n  let [funString, sourceMapString] = buildWorkletString(\n    transformed.ast,\n    state,\n    variables,\n    workletName,\n    transformed.map\n  );\n  assert(funString, '[Reanimated] `funString` is undefined.');\n  const workletHash = hash(funString);\n\n  let lineOffset = 1;\n  if (variables.length > 0) {\n    // When worklet captures some variables, we append closure destructing at\n    // the beginning of the function body. This effectively results in line\n    // numbers shifting by the number of captured variables (size of the\n    // closure) + 2 (for the opening and closing brackets of the destruct\n    // statement)\n    lineOffset -= variables.length + 2;\n  }\n\n  const pathForStringDefinitions = fun.parentPath.isProgram()\n    ? fun\n    : fun.findParent((path) => path.parentPath?.isProgram() ?? false);\n  assert(\n    pathForStringDefinitions,\n    '[Reanimated] `pathForStringDefinitions` is null.'\n  );\n  assert(\n    pathForStringDefinitions.parentPath,\n    '[Reanimated] `pathForStringDefinitions.parentPath` is null.'\n  );\n\n  const initDataId =\n    pathForStringDefinitions.parentPath.scope.generateUidIdentifier(\n      `worklet_${workletHash}_init_data`\n    );\n\n  const initDataObjectExpression = objectExpression([\n    objectProperty(identifier('code'), stringLiteral(funString)),\n  ]);\n\n  // When testing with jest I noticed that environment variables are set later\n  // than some functions are evaluated. E.g. this cannot be above this function\n  // because it would always evaluate to true.\n  const shouldInjectLocation = !isRelease();\n  if (shouldInjectLocation) {\n    let location = state.file.opts.filename;\n    if (state.opts.relativeSourceLocation) {\n      location = relative(state.cwd, location);\n      // It seems there is no designated option to use relative paths in generated sourceMap\n      sourceMapString = sourceMapString?.replace(\n        state.file.opts.filename,\n        location\n      );\n    }\n\n    initDataObjectExpression.properties.push(\n      objectProperty(identifier('location'), stringLiteral(location))\n    );\n  }\n\n  if (sourceMapString) {\n    initDataObjectExpression.properties.push(\n      objectProperty(identifier('sourceMap'), stringLiteral(sourceMapString))\n    );\n  }\n\n  const shouldInjectVersion = !isRelease();\n  if (shouldInjectVersion) {\n    initDataObjectExpression.properties.push(\n      objectProperty(\n        identifier('version'),\n        stringLiteral(shouldMockVersion() ? MOCK_VERSION : REAL_VERSION)\n      )\n    );\n  }\n\n  const shouldIncludeInitData = !state.opts.omitNativeOnlyData;\n  if (shouldIncludeInitData) {\n    pathForStringDefinitions.insertBefore(\n      variableDeclaration('const', [\n        variableDeclarator(initDataId, initDataObjectExpression),\n      ])\n    );\n  }\n\n  assert(\n    !isFunctionDeclaration(funExpression),\n    '[Reanimated] `funExpression` is a `FunctionDeclaration`.'\n  );\n  assert(\n    !isObjectMethod(funExpression),\n    '[Reanimated] `funExpression` is an `ObjectMethod`.'\n  );\n\n  const statements: Array<\n    VariableDeclaration | ExpressionStatement | ReturnStatement\n  > = [\n    variableDeclaration('const', [\n      variableDeclarator(identifier(reactName), funExpression),\n    ]),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(identifier(reactName), identifier('__closure'), false),\n        objectExpression(\n          variables.map((variable) =>\n            variable.name.endsWith(workletClassFactorySuffix)\n              ? objectProperty(\n                  identifier(variable.name),\n                  memberExpression(\n                    identifier(\n                      variable.name.slice(\n                        0,\n                        variable.name.length - workletClassFactorySuffix.length\n                      )\n                    ),\n                    identifier(variable.name)\n                  )\n                )\n              : objectProperty(identifier(variable.name), variable, false, true)\n          )\n        )\n      )\n    ),\n    expressionStatement(\n      assignmentExpression(\n        '=',\n        memberExpression(\n          identifier(reactName),\n          identifier('__workletHash'),\n          false\n        ),\n        numericLiteral(workletHash)\n      )\n    ),\n  ];\n\n  if (shouldIncludeInitData) {\n    statements.push(\n      expressionStatement(\n        assignmentExpression(\n          '=',\n          memberExpression(\n            identifier(reactName),\n            identifier('__initData'),\n            false\n          ),\n          initDataId\n        )\n      )\n    );\n  }\n\n  if (!isRelease()) {\n    statements.unshift(\n      variableDeclaration('const', [\n        variableDeclarator(\n          identifier('_e'),\n          arrayExpression([\n            newExpression(\n              memberExpression(identifier('global'), identifier('Error')),\n              []\n            ),\n            numericLiteral(lineOffset),\n            numericLiteral(-27), // the placement of opening bracket after Exception in line that defined '_e' variable\n          ])\n        ),\n      ])\n    );\n    statements.push(\n      expressionStatement(\n        assignmentExpression(\n          '=',\n          memberExpression(\n            identifier(reactName),\n            identifier('__stackDetails'),\n            false\n          ),\n          identifier('_e')\n        )\n      )\n    );\n  }\n\n  statements.push(returnStatement(identifier(reactName)));\n\n  const newFun = functionExpression(undefined, [], blockStatement(statements));\n\n  return newFun;\n}\n\nfunction removeWorkletDirective(fun: NodePath<WorkletizableFunction>): void {\n  fun.traverse({\n    DirectiveLiteral(path) {\n      if (path.node.value === 'worklet' && path.getFunctionParent() === fun) {\n        path.parentPath.remove();\n      }\n    },\n  });\n}\n\nfunction shouldMockVersion(): boolean {\n  // We don't want to pollute tests with current version number so we mock it\n  // for all tests (except one)\n  return process.env.REANIMATED_JEST_SHOULD_MOCK_VERSION === '1';\n}\n\nfunction hash(str: string): number {\n  let i = str.length;\n  let hash1 = 5381;\n  let hash2 = 52711;\n\n  while (i--) {\n    const char = str.charCodeAt(i);\n    // eslint-disable-next-line no-bitwise\n    hash1 = (hash1 * 33) ^ char;\n    // eslint-disable-next-line no-bitwise\n    hash2 = (hash2 * 33) ^ char;\n  }\n\n  // eslint-disable-next-line no-bitwise\n  return (hash1 >>> 0) * 4096 + (hash2 >>> 0);\n}\n\nfunction makeWorkletName(\n  fun: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): { workletName: string; reactName: string } {\n  let source = 'unknownFile';\n\n  if (state.file.opts.filename) {\n    const filepath = state.file.opts.filename;\n    source = basename(filepath);\n\n    // Get the library name from the path.\n    const splitFilepath = filepath.split('/');\n    const nodeModulesIndex = splitFilepath.indexOf('node_modules');\n    if (nodeModulesIndex !== -1) {\n      const libraryName = splitFilepath[nodeModulesIndex + 1];\n      source = `${libraryName}_${source}`;\n    }\n  }\n\n  const suffix = `${source}${state.workletNumber++}`;\n  let reactName = '';\n\n  if (isObjectMethod(fun.node) && isIdentifier(fun.node.key)) {\n    reactName = fun.node.key.name;\n  } else if (\n    (isFunctionDeclaration(fun.node) || isFunctionExpression(fun.node)) &&\n    isIdentifier(fun.node.id)\n  ) {\n    reactName = fun.node.id.name;\n  }\n\n  const workletName = reactName\n    ? toIdentifier(`${reactName}_${suffix}`)\n    : toIdentifier(suffix);\n\n  // Fallback for ArrowFunctionExpression and unnamed FunctionExpression.\n  reactName = reactName || toIdentifier(suffix);\n\n  return { workletName, reactName };\n}\n\nfunction makeArrayFromCapturedBindings(\n  ast: BabelFile,\n  fun: NodePath<WorkletizableFunction>\n): Identifier[] {\n  const closure = new Map<string, Identifier>();\n  const isLocationAssignedMap = new Map<string, boolean>();\n\n  // this traversal looks for variables to capture\n  traverse(ast, {\n    Identifier(path) {\n      // we only capture variables that were declared outside of the scope\n      if (!path.isReferencedIdentifier()) {\n        return;\n      }\n      const name = path.node.name;\n      // if the function is named and was added to globals we don't want to add it to closure\n      // hence we check if identifier has that name\n      if (globals.has(name)) {\n        return;\n      }\n      if (\n        'id' in fun.node &&\n        fun.node.id &&\n        fun.node.id.name === name // we don't want to capture function's own name\n      ) {\n        return;\n      }\n\n      const parentNode = path.parent;\n\n      if (\n        isMemberExpression(parentNode) &&\n        parentNode.property === path.node &&\n        !parentNode.computed\n      ) {\n        return;\n      }\n\n      if (\n        isObjectProperty(parentNode) &&\n        isObjectExpression(path.parentPath.parent) &&\n        path.node !== parentNode.value\n      ) {\n        return;\n      }\n\n      let currentScope = path.scope;\n\n      while (currentScope != null) {\n        if (currentScope.bindings[name] != null) {\n          return;\n        }\n        currentScope = currentScope.parent;\n      }\n      closure.set(name, path.node);\n      isLocationAssignedMap.set(name, false);\n    },\n  });\n\n  /*\n  For reasons I don't exactly understand, the above traversal will cause the whole \n  bundle to crash if we traversed original node instead of generated\n  AST. This is why we need to traverse it again, but this time we set\n  location for each identifier that was captured to their original counterpart, since\n  AST has its location set relative as if it was a separate file.\n  */\n  fun.traverse({\n    Identifier(path) {\n      // So it won't refer to something like:\n      // const obj = {unexistingVariable: 1};\n      if (!path.isReferencedIdentifier()) {\n        return;\n      }\n      const node = closure.get(path.node.name);\n      if (!node || isLocationAssignedMap.get(path.node.name)) {\n        return;\n      }\n      node.loc = path.node.loc;\n      isLocationAssignedMap.set(path.node.name, true);\n    },\n  });\n\n  return Array.from(closure.values());\n}\n", "import type { NodePath } from '@babel/core';\nimport { callExpression } from '@babel/types';\nimport type { CallExpression } from '@babel/types';\nimport type { ReanimatedPluginPass, WorkletizableFunction } from './types';\nimport { makeWorkletFactory } from './workletFactory';\n\nexport function makeWorkletFactoryCall(\n  path: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): CallExpression {\n  const workletFactory = makeWorkletFactory(path, state);\n\n  const workletFactoryCall = callExpression(workletFactory, []);\n\n  addStackTraceDataToWorkletFactory(path, workletFactoryCall);\n\n  const replacement = workletFactoryCall;\n\n  return replacement;\n}\n\n/* \n  If for some reason the code of the worklet is so bad that it\n  causes the worklet factory to crash, eg.:\n\n  function foo() {\n    'worklet'\n    unexistingVariable;\n  };\n\n  Such function will cause the factory to crash on closure creation because\n  of reference to `unexistingVariable`.\n  \n  With this we are able to give a meaningful stack trace - we use `start` twice on purpose, since\n  crashing on the factory leads to its end on the stack trace - the closing bracket. It's more\n  approachable this way, when it points to the start of the original function.\n  */\nfunction addStackTraceDataToWorkletFactory(\n  path: NodePath<WorkletizableFunction>,\n  workletFactoryCall: CallExpression\n): void {\n  const originalWorkletLocation = path.node.loc;\n  if (originalWorkletLocation) {\n    workletFactoryCall.callee.loc = {\n      filename: originalWorkletLocation.filename,\n      identifierName: originalWorkletLocation.identifierName,\n      start: originalWorkletLocation.start,\n      end: originalWorkletLocation.start,\n    };\n  }\n}\n", "import type { NodePath } from '@babel/core';\nimport type { CallExpression, Directive, ObjectMethod } from '@babel/types';\nimport {\n  isBlockStatement,\n  isDirectiveLiteral,\n  objectProperty,\n} from '@babel/types';\nimport type { ReanimatedPluginPass } from './types';\nimport { WorkletizableFunction } from './types';\nimport { replaceWithFactoryCall } from './utils';\nimport { makeWorkletFactoryCall } from './workletFactoryCall';\n\n/** @returns `true` if the function was workletized, `false` otherwise. */\nexport function processIfWithWorkletDirective(\n  path: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): boolean {\n  if (!isBlockStatement(path.node.body)) {\n    // If the function body is not a block statement we can safely assume that it's not a worklet\n    // since it's the case of an arrow function with immediate return\n    // eg. `const foo = () => 1;`\n    return false;\n  }\n  if (!hasWorkletDirective(path.node.body.directives)) {\n    return false;\n  }\n  processWorklet(path, state);\n  return true;\n}\n\n/**\n * Replaces\n *\n * - `FunctionDeclaration`,\n * - `FunctionExpression`,\n * - `ArrowFunctionExpression`\n * - `ObjectMethod`\n *\n * With a workletized version of itself.\n */\nexport function processWorklet(\n  path: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): void {\n  if (state.opts.processNestedWorklets) {\n    path.traverse(\n      {\n        // @ts-expect-error TypeScript doesn't like this syntax here.\n        [WorkletizableFunction](\n          subPath: NodePath<WorkletizableFunction>,\n          passedState: ReanimatedPluginPass\n        ): void {\n          processIfWithWorkletDirective(subPath, passedState);\n        },\n      },\n      state\n    );\n  }\n\n  const workletFactoryCall = makeWorkletFactoryCall(path, state);\n\n  substituteWorkletWithWorkletFactoryCall(path, workletFactoryCall);\n}\n\nfunction hasWorkletDirective(directives: Directive[]): boolean {\n  return directives.some(\n    (directive) =>\n      isDirectiveLiteral(directive.value) && directive.value.value === 'worklet'\n  );\n}\n\nfunction substituteWorkletWithWorkletFactoryCall(\n  path: NodePath<WorkletizableFunction>,\n  workletFactoryCall: CallExpression\n): void {\n  if (path.isObjectMethod()) {\n    substituteObjectMethodWithObjectProperty(path, workletFactoryCall);\n  } else {\n    const name = 'id' in path.node ? path.node.id?.name : undefined;\n    replaceWithFactoryCall(path, name, workletFactoryCall);\n  }\n}\n\nexport function substituteObjectMethodWithObjectProperty(\n  path: NodePath<ObjectMethod>,\n  workletFactoryCall: CallExpression\n): void {\n  const replacement = objectProperty(path.node.key, workletFactoryCall);\n  path.replaceWith(replacement);\n}\n", "import type { NodePath } from '@babel/core';\nimport type { Expression } from '@babel/types';\nimport {\n  isIdentifier,\n  isCallExpression,\n  isMemberExpression,\n  isExpression,\n} from '@babel/types';\nimport type { WorkletizableFunction } from './types';\n\nconst gestureHandlerGestureObjects = new Set([\n  'Tap',\n  'Pan',\n  'Pinch',\n  'Rotation',\n  'Fling',\n  'LongPress',\n  'ForceTouch',\n  'Native',\n  'Manual',\n  'Race',\n  'Simultaneous',\n  'Exclusive',\n  'Hover',\n]);\n\nconst gestureHandlerBuilderMethods = new Set([\n  'onBegin',\n  'onStart',\n  'onEnd',\n  'onFinalize',\n  'onUpdate',\n  'onChange',\n  'onTouchesDown',\n  'onTouchesMove',\n  'onTouchesUp',\n  'onTouchesCancelled',\n]);\n\n// Auto-workletizes React Native Gesture Handler callback functions.\n// Detects `Gesture.Tap().onEnd(<fun>)` or similar, but skips `something.onEnd(<fun>)`.\n// Supports method chaining as well, e.g. `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`.\n\n// Example #1: `Gesture.Tap().onEnd(<fun>)`\n/*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: Identifier('Gesture')\n          property: Identifier('Tap')\n        )\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun]\n  )\n  */\n\n// Example #2: `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`\n/*\n  CallExpression(\n    callee: MemberExpression(\n      object: CallExpression(\n        callee: MemberExpression(\n          object: CallExpression(\n            callee: MemberExpression(\n              object: CallExpression(\n                callee: MemberExpression(\n                  object: Identifier('Gesture')\n                  property: Identifier('Tap')\n                )\n              )\n              property: Identifier('onStart')\n            )\n            arguments: [fun1]\n          )\n          property: Identifier('onUpdate')\n        )\n        arguments: [fun2]\n      )\n      property: Identifier('onEnd')\n    )\n    arguments: [fun3]\n  )\n  */\nexport function isGestureHandlerEventCallback(\n  path: NodePath<WorkletizableFunction>\n): boolean {\n  return (\n    isCallExpression(path.parent) &&\n    isExpression(path.parent.callee) &&\n    isGestureObjectEventCallbackMethod(path.parent.callee)\n  );\n}\n\nfunction isGestureObjectEventCallbackMethod(exp: Expression): boolean {\n  // Checks if node matches the pattern `Gesture.Foo()[*].onBar`\n  // where `[*]` represents any number of method calls.\n  return (\n    isMemberExpression(exp) &&\n    isIdentifier(exp.property) &&\n    gestureHandlerBuilderMethods.has(exp.property.name) &&\n    containsGestureObject(exp.object)\n  );\n}\n\nfunction containsGestureObject(exp: Expression): boolean {\n  // Checks if node matches the pattern `Gesture.Foo()[*]`\n  // where `[*]` represents any number of chained method calls, like `.something(42)`.\n\n  // direct call\n  if (isGestureObject(exp)) {\n    return true;\n  }\n\n  // method chaining\n  if (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    containsGestureObject(exp.callee.object)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isGestureObject(exp: Expression): boolean {\n  // Checks if node matches `Gesture.Tap()` or similar.\n  /*\n  node: CallExpression(\n    callee: MemberExpression(\n      object: Identifier('Gesture')\n      property: Identifier('Tap')\n    )\n  )\n  */\n  return (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    isIdentifier(exp.callee.object) &&\n    exp.callee.object.name === 'Gesture' &&\n    isIdentifier(exp.callee.property) &&\n    gestureHandlerGestureObjects.has(exp.callee.property.name)\n  );\n}\n", "import type { NodePath } from '@babel/core';\nimport type { Expression } from '@babel/types';\nimport {\n  isIdentifier,\n  isCallExpression,\n  isMemberExpression,\n  isExpression,\n  isNewExpression,\n} from '@babel/types';\nimport type { WorkletizableFunction } from './types';\n\nconst EntryExitAnimations = new Set([\n  'BounceIn',\n  'BounceInDown',\n  'BounceInLeft',\n  'BounceInRight',\n  'BounceInUp',\n  'BounceOut',\n  'BounceOutDown',\n  'BounceOutLeft',\n  'BounceOutRight',\n  'BounceOutUp',\n  'FadeIn',\n  'FadeInDown',\n  'FadeInLeft',\n  'FadeInRight',\n  'FadeInUp',\n  'FadeOut',\n  'FadeOutDown',\n  'FadeOutLeft',\n  'FadeOutRight',\n  'FadeOutUp',\n  'FlipInEasyX',\n  'FlipInEasyY',\n  'FlipInXDown',\n  'FlipInXUp',\n  'FlipInYLeft',\n  'FlipInYRight',\n  'FlipOutEasyX',\n  'FlipOutEasyY',\n  'FlipOutXDown',\n  'FlipOutXUp',\n  'FlipOutYLeft',\n  'FlipOutYRight',\n  'LightSpeedInLeft',\n  'LightSpeedInRight',\n  'LightSpeedOutLeft',\n  'LightSpeedOutRight',\n  'PinwheelIn',\n  'PinwheelOut',\n  'RollInLeft',\n  'RollInRight',\n  'RollOutLeft',\n  'RollOutRight',\n  'RotateInDownLeft',\n  'RotateInDownRight',\n  'RotateInUpLeft',\n  'RotateInUpRight',\n  'RotateOutDownLeft',\n  'RotateOutDownRight',\n  'RotateOutUpLeft',\n  'RotateOutUpRight',\n  'SlideInDown',\n  'SlideInLeft',\n  'SlideInRight',\n  'SlideInUp',\n  'SlideOutDown',\n  'SlideOutLeft',\n  'SlideOutRight',\n  'SlideOutUp',\n  'StretchInX',\n  'StretchInY',\n  'StretchOutX',\n  'StretchOutY',\n  'ZoomIn',\n  'ZoomInDown',\n  'ZoomInEasyDown',\n  'ZoomInEasyUp',\n  'ZoomInLeft',\n  'ZoomInRight',\n  'ZoomInRotate',\n  'ZoomInUp',\n  'ZoomOut',\n  'ZoomOutDown',\n  'ZoomOutEasyDown',\n  'ZoomOutEasyUp',\n  'ZoomOutLeft',\n  'ZoomOutRight',\n  'ZoomOutRotate',\n  'ZoomOutUp',\n]);\n\nconst LayoutTransitions = new Set([\n  'Layout',\n  'LinearTransition',\n  'SequencedTransition',\n  'FadingTransition',\n  'JumpingTransition',\n  'CurvedTransition',\n  'EntryExitTransition',\n]);\n\nconst LayoutAnimations = new Set([\n  ...EntryExitAnimations,\n  ...LayoutTransitions,\n]);\n\nconst BaseAnimationsChainableMethods = new Set([\n  'build',\n  'duration',\n  'delay',\n  'getDuration',\n  'randomDelay',\n  'getDelay',\n  'getDelayFunction',\n]);\n\nconst ComplexAnimationsChainableMethods = new Set([\n  'easing',\n  'rotate',\n  'springify',\n  'damping',\n  'mass',\n  'stiffness',\n  'overshootClamping',\n  'restDisplacementThreshold',\n  'restSpeedThreshold',\n  'withInitialValues',\n  'getAnimationAndConfig',\n]);\n\nconst DefaultTransitionChainableMethods = new Set([\n  'easingX',\n  'easingY',\n  'easingWidth',\n  'easingHeight',\n  'entering',\n  'exiting',\n  'reverse',\n]);\n\nconst LayoutAnimationsChainableMethods = new Set([\n  ...BaseAnimationsChainableMethods,\n  ...ComplexAnimationsChainableMethods,\n  ...DefaultTransitionChainableMethods,\n]);\n\nconst LayoutAnimationsCallbacks = new Set(['withCallback']);\n\nexport function isLayoutAnimationCallback(\n  path: NodePath<WorkletizableFunction>\n): boolean {\n  return (\n    isCallExpression(path.parent) &&\n    isExpression(path.parent.callee) &&\n    isLayoutAnimationCallbackMethod(path.parent.callee)\n  );\n}\n\nfunction isLayoutAnimationCallbackMethod(exp: Expression): boolean {\n  return (\n    isMemberExpression(exp) &&\n    isIdentifier(exp.property) &&\n    LayoutAnimationsCallbacks.has(exp.property.name) &&\n    isLayoutAnimationsChainableOrNewOperator(exp.object)\n  );\n}\n\nfunction isLayoutAnimationsChainableOrNewOperator(exp: Expression): boolean {\n  if (isIdentifier(exp) && LayoutAnimations.has(exp.name)) {\n    return true;\n  } else if (\n    isNewExpression(exp) &&\n    isIdentifier(exp.callee) &&\n    LayoutAnimations.has(exp.callee.name)\n  ) {\n    return true;\n  }\n  if (\n    isCallExpression(exp) &&\n    isMemberExpression(exp.callee) &&\n    isIdentifier(exp.callee.property) &&\n    LayoutAnimationsChainableMethods.has(exp.callee.property.name) &&\n    isLayoutAnimationsChainableOrNewOperator(exp.callee.object)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n", "import type { NodePath } from '@babel/core';\nimport type { AssignmentExpression, Identifier } from '@babel/types';\nimport {\n  isWorkletizableFunctionPath,\n  isWorkletizableObjectPath,\n} from './types';\nimport type { WorkletizableFunction, WorkletizableObject } from './types';\nimport type { Binding } from '@babel/traverse';\n\nexport function findReferencedWorklet(\n  workletIdentifier: NodePath<Identifier>,\n  acceptWorkletizableFunction: boolean,\n  acceptObject: boolean\n): NodePath<WorkletizableFunction> | NodePath<WorkletizableObject> | undefined {\n  const workletName = workletIdentifier.node.name;\n  const scope = workletIdentifier.scope;\n\n  const workletBinding = scope.getBinding(workletName);\n  if (!workletBinding) {\n    return undefined;\n  }\n\n  if (\n    acceptWorkletizableFunction &&\n    workletBinding.path.isFunctionDeclaration()\n  ) {\n    return workletBinding.path;\n  }\n\n  const isConstant = workletBinding.constant;\n  if (isConstant) {\n    return findReferencedWorkletFromVariableDeclarator(\n      workletBinding,\n      acceptWorkletizableFunction,\n      acceptObject\n    );\n  }\n  return findReferencedWorkletFromAssignmentExpression(\n    workletBinding,\n    acceptWorkletizableFunction,\n    acceptObject\n  );\n}\n\nfunction findReferencedWorkletFromVariableDeclarator(\n  workletBinding: Binding,\n  acceptWorkletizableFunction: boolean,\n  acceptObject: boolean\n): NodePath<WorkletizableFunction> | NodePath<WorkletizableObject> | undefined {\n  const workletDeclaration = workletBinding.path;\n  if (!workletDeclaration.isVariableDeclarator()) {\n    return undefined;\n  }\n  const worklet = workletDeclaration.get('init');\n\n  if (acceptWorkletizableFunction && isWorkletizableFunctionPath(worklet)) {\n    return worklet;\n  }\n  if (acceptObject && isWorkletizableObjectPath(worklet)) {\n    return worklet;\n  }\n  return undefined;\n}\n\nfunction findReferencedWorkletFromAssignmentExpression(\n  workletBinding: Binding,\n  acceptWorkletizableFunction: boolean,\n  acceptObject: boolean\n): NodePath<WorkletizableFunction> | NodePath<WorkletizableObject> | undefined {\n  const workletDeclaration = workletBinding.constantViolations\n    .reverse()\n    .find(\n      (constantViolation) =>\n        constantViolation.isAssignmentExpression() &&\n        ((acceptWorkletizableFunction &&\n          isWorkletizableFunctionPath(constantViolation.get('right'))) ||\n          (acceptObject &&\n            isWorkletizableObjectPath(constantViolation.get('right'))))\n    ) as NodePath<AssignmentExpression> | undefined;\n\n  if (!workletDeclaration || !workletDeclaration.isAssignmentExpression()) {\n    return undefined;\n  }\n\n  const workletDefinition = workletDeclaration.get('right');\n\n  if (\n    acceptWorkletizableFunction &&\n    isWorkletizableFunctionPath(workletDefinition)\n  ) {\n    return workletDefinition;\n  }\n  if (acceptObject && isWorkletizableObjectPath(workletDefinition)) {\n    return workletDefinition;\n  }\n  return undefined;\n}\n", "import type { NodePath } from '@babel/core';\nimport { isWorkletizableFunctionPath } from './types';\nimport type { WorkletizableObject, ReanimatedPluginPass } from './types';\nimport { processWorklet } from './workletSubstitution';\n\nexport function processWorkletizableObject(\n  path: NodePath<WorkletizableObject>,\n  state: ReanimatedPluginPass\n): void {\n  const properties = path.get('properties');\n  for (const property of properties) {\n    if (property.isObjectMethod()) {\n      processWorklet(property, state);\n    } else if (property.isObjectProperty()) {\n      const value = property.get('value');\n      if (isWorkletizableFunctionPath(value)) {\n        processWorklet(value, state);\n      }\n    } else {\n      throw new Error(\n        `[Reanimated] '${property.type}' as to-be workletized argument is not supported for object hooks.`\n      );\n    }\n  }\n}\n", "import type { NodePath } from '@babel/core';\nimport type { CallExpression } from '@babel/types';\nimport { isSequenceExpression } from '@babel/types';\nimport {\n  isWorkletizableFunctionPath,\n  isWorkletizableObjectPath,\n} from './types';\nimport type {\n  WorkletizableFunction,\n  WorkletizableObject,\n  ReanimatedPluginPass,\n} from './types';\nimport { processWorklet } from './workletSubstitution';\nimport { isGestureHandlerEventCallback } from './gestureHandlerAutoworkletization';\nimport { isLayoutAnimationCallback } from './layoutAnimationAutoworkletization';\nimport { findReferencedWorklet } from './referencedWorklets';\nimport { processWorkletizableObject } from './objectWorklets';\n\nconst objectHooks = new Set([\n  'useAnimatedGestureHandler',\n  'useAnimatedScrollHandler',\n]);\n\nconst functionHooks = new Set([\n  'useFrameCallback',\n  'useAnimatedStyle',\n  'useAnimatedProps',\n  'createAnimatedPropAdapter',\n  'useDerivedValue',\n  'useAnimatedScrollHandler',\n  'useAnimatedReaction',\n  'useWorkletCallback',\n  // animations' callbacks\n  'withTiming',\n  'withSpring',\n  'withDecay',\n  'withRepeat',\n  // scheduling functions\n  'runOnUI',\n  'executeOnUIRuntimeSync',\n]);\n\nconst functionArgsToWorkletize = new Map([\n  ['useAnimatedGestureHandler', [0]],\n  ['useFrameCallback', [0]],\n  ['useAnimatedStyle', [0]],\n  ['useAnimatedProps', [0]],\n  ['createAnimatedPropAdapter', [0]],\n  ['useDerivedValue', [0]],\n  ['useAnimatedScrollHandler', [0]],\n  ['useAnimatedReaction', [0, 1]],\n  ['useWorkletCallback', [0]],\n  ['withTiming', [2]],\n  ['withSpring', [2]],\n  ['withDecay', [1]],\n  ['withRepeat', [3]],\n  ['runOnUI', [0]],\n  ['executeOnUIRuntimeSync', [0]],\n]);\n\n/** @returns `true` if the function was workletized, `false` otherwise. */\nexport function processIfAutoworkletizableCallback(\n  path: NodePath<WorkletizableFunction>,\n  state: ReanimatedPluginPass\n): boolean {\n  if (isGestureHandlerEventCallback(path) || isLayoutAnimationCallback(path)) {\n    processWorklet(path, state);\n    return true;\n  }\n  return false;\n}\n\nexport function processCalleesAutoworkletizableCallbacks(\n  path: NodePath<CallExpression>,\n  state: ReanimatedPluginPass\n): void {\n  const callee = isSequenceExpression(path.node.callee)\n    ? path.node.callee.expressions[path.node.callee.expressions.length - 1]\n    : path.node.callee;\n\n  // We are looking for objects we know we should workletize\n  // hence if object is not named, we return.\n  const name =\n    'name' in callee\n      ? callee.name\n      : 'property' in callee && 'name' in callee.property\n        ? callee.property.name\n        : undefined;\n  if (name === undefined) {\n    return;\n  }\n\n  if (functionHooks.has(name) || objectHooks.has(name)) {\n    const acceptWorkletizableFunction = functionHooks.has(name);\n    const acceptObject = objectHooks.has(name);\n    const argIndices = functionArgsToWorkletize.get(name)!;\n    const args = path\n      .get('arguments')\n      .filter((_, index) => argIndices.includes(index));\n\n    processArgs(args, state, acceptWorkletizableFunction, acceptObject);\n  }\n}\n\nfunction processArgs(\n  args: NodePath[],\n  state: ReanimatedPluginPass,\n  acceptWorkletizableFunction: boolean,\n  acceptObject: boolean\n): void {\n  args.forEach((arg) => {\n    const maybeWorklet = findWorklet(\n      arg,\n      acceptWorkletizableFunction,\n      acceptObject\n    );\n    if (!maybeWorklet) {\n      return;\n    }\n    if (isWorkletizableFunctionPath(maybeWorklet)) {\n      processWorklet(maybeWorklet, state);\n    } else if (isWorkletizableObjectPath(maybeWorklet)) {\n      processWorkletizableObject(maybeWorklet, state);\n    }\n  });\n}\n\nfunction findWorklet(\n  arg: NodePath,\n  acceptWorkletizableFunction: boolean,\n  acceptObject: boolean\n): NodePath<WorkletizableFunction> | NodePath<WorkletizableObject> | undefined {\n  if (acceptWorkletizableFunction && isWorkletizableFunctionPath(arg)) {\n    return arg;\n  }\n  if (acceptObject && isWorkletizableObjectPath(arg)) {\n    return arg;\n  }\n  if (arg.isReferencedIdentifier() && arg.isIdentifier()) {\n    return findReferencedWorklet(\n      arg,\n      acceptWorkletizableFunction,\n      acceptObject\n    );\n  }\n  return undefined;\n}\n", "import type { NodePath } from '@babel/core';\nimport {\n  blockStatement,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  functionExpression,\n  identifier,\n  isIdentifier,\n  isObjectProperty,\n  objectProperty,\n  returnStatement,\n} from '@babel/types';\nimport type { ObjectExpression } from '@babel/types';\nimport type { ReanimatedPluginPass } from './types';\n\nexport const contextObjectMarker = '__workletContextObject';\n\nexport function processIfWorkletContextObject(\n  path: NodePath<ObjectExpression>,\n  _state: ReanimatedPluginPass\n): boolean {\n  if (!isContextObject(path.node)) {\n    return false;\n  }\n\n  removeContextObjectMarker(path.node);\n  processWorkletContextObject(path.node);\n  return true;\n}\n\nexport function isContextObject(objectExpression: ObjectExpression): boolean {\n  return objectExpression.properties.some(\n    (property) =>\n      isObjectProperty(property) &&\n      isIdentifier(property.key) &&\n      property.key.name === contextObjectMarker\n  );\n}\n\nfunction processWorkletContextObject(objectExpression: ObjectExpression): void {\n  // A simple factory function that returns the context object.\n  const workletObjectFactory = functionExpression(\n    null,\n    [],\n    blockStatement(\n      [returnStatement(cloneNode(objectExpression))],\n      [directive(directiveLiteral('worklet'))]\n    )\n  );\n\n  objectExpression.properties.push(\n    objectProperty(\n      identifier(`${contextObjectMarker}Factory`),\n      workletObjectFactory\n    )\n  );\n}\n\nfunction removeContextObjectMarker(objectExpression: ObjectExpression): void {\n  objectExpression.properties = objectExpression.properties.filter(\n    (property) =>\n      !(\n        isObjectProperty(property) &&\n        isIdentifier(property.key) &&\n        property.key.name === contextObjectMarker\n      )\n  );\n}\n", "import {\n  blockStatement,\n  booleanLiteral,\n  classProperty,\n  directive,\n  directiveLiteral,\n  identifier,\n  isAssignmentExpression,\n  isBlockStatement,\n  isExpressionStatement,\n  isIdentifier,\n  isMemberExpression,\n  isObjectProperty,\n  objectProperty,\n  returnStatement,\n} from '@babel/types';\n\nimport type {\n  Program,\n  BlockStatement,\n  VariableDeclaration,\n  ArrowFunctionExpression,\n  ObjectExpression,\n  Statement,\n  ThisExpression,\n  ObjectMethod,\n  ClassBody,\n} from '@babel/types';\nimport type { NodePath } from '@babel/core';\nimport {\n  isWorkletizableFunctionPath,\n  isWorkletizableObjectPath,\n} from './types';\nimport type { ReanimatedPluginPass } from './types';\nimport { contextObjectMarker } from './contextObject';\n\nexport function processIfWorkletFile(\n  path: NodePath<Program>,\n  _state: ReanimatedPluginPass\n): boolean {\n  if (\n    !path.node.directives.some(\n      (functionDirective) => functionDirective.value.value === 'worklet'\n    )\n  ) {\n    return false;\n  }\n\n  // Remove 'worklet' directive from the file.\n  path.node.directives = path.node.directives.filter(\n    (functionDirective) => functionDirective.value.value !== 'worklet'\n  );\n  processWorkletFile(path);\n\n  return true;\n}\n\n/** Adds a worklet directive to each viable top-level entity in the file. */\nfunction processWorkletFile(programPath: NodePath<Program>) {\n  const statements = programPath.get('body');\n  dehoistCommonJSExports(programPath.node);\n  statements.forEach((statement) => {\n    const candidatePath = getCandidate(statement);\n    processWorkletizableEntity(candidatePath);\n  });\n}\n\nfunction getCandidate(statementPath: NodePath<Statement>) {\n  if (\n    statementPath.isExportNamedDeclaration() ||\n    statementPath.isExportDefaultDeclaration()\n  ) {\n    return statementPath.get('declaration') as NodePath<unknown>;\n  } else {\n    return statementPath;\n  }\n}\n\nfunction processWorkletizableEntity(nodePath: NodePath<unknown>) {\n  if (isWorkletizableFunctionPath(nodePath)) {\n    if (nodePath.isArrowFunctionExpression()) {\n      replaceImplicitReturnWithBlock(nodePath.node);\n    }\n    appendWorkletDirective(nodePath.node.body as BlockStatement);\n  } else if (isWorkletizableObjectPath(nodePath)) {\n    if (isImplicitContextObject(nodePath)) {\n      appendWorkletContextObjectMarker(nodePath.node);\n    } else {\n      processWorkletAggregator(nodePath);\n    }\n  } else if (nodePath.isVariableDeclaration()) {\n    processVariableDeclaration(nodePath);\n  } else if (nodePath.isClassDeclaration()) {\n    appendWorkletClassMarker(nodePath.node.body);\n  }\n}\n\nfunction processVariableDeclaration(\n  variableDeclarationPath: NodePath<VariableDeclaration>\n) {\n  const declarations = variableDeclarationPath.get('declarations');\n  declarations.forEach((declaration) => {\n    const initPath = declaration.get('init');\n    if (initPath.isExpression()) {\n      processWorkletizableEntity(initPath);\n    }\n  });\n}\n\nfunction processWorkletAggregator(objectPath: NodePath<ObjectExpression>) {\n  const properties = objectPath.get('properties');\n  properties.forEach((property) => {\n    if (property.isObjectMethod()) {\n      appendWorkletDirective(property.node.body);\n    } else if (property.isObjectProperty()) {\n      const valuePath = property.get('value');\n      processWorkletizableEntity(valuePath);\n    }\n  });\n}\n\n/**\n * Replaces implicit return statements with a block statement i.e.:\n *\n * `() => 1` becomes `() => { return 1 }`\n *\n * This is necessary because the worklet directive is only allowed on block\n * statements.\n */\nfunction replaceImplicitReturnWithBlock(path: ArrowFunctionExpression) {\n  if (!isBlockStatement(path.body)) {\n    path.body = blockStatement([returnStatement(path.body)]);\n  }\n}\n\nfunction appendWorkletDirective(node: BlockStatement) {\n  if (\n    !node.directives.some(\n      (functionDirective) => functionDirective.value.value === 'worklet'\n    )\n  ) {\n    node.directives.push(directive(directiveLiteral('worklet')));\n  }\n}\n\nfunction appendWorkletContextObjectMarker(objectExpression: ObjectExpression) {\n  if (\n    objectExpression.properties.some(\n      (value) =>\n        isObjectProperty(value) &&\n        isIdentifier(value.key) &&\n        value.key.name === contextObjectMarker\n    )\n  ) {\n    return;\n  }\n\n  objectExpression.properties.push(\n    objectProperty(identifier(`${contextObjectMarker}`), booleanLiteral(true))\n  );\n}\n\nexport function isImplicitContextObject(\n  path: NodePath<ObjectExpression>\n): boolean {\n  const propertyPaths = path.get('properties');\n\n  return propertyPaths.some((propertyPath) => {\n    if (!propertyPath.isObjectMethod()) {\n      return false;\n    }\n\n    return hasThisExpression(propertyPath);\n  });\n}\n\nfunction hasThisExpression(path: NodePath<ObjectMethod>): boolean {\n  let result = false;\n\n  path.traverse({\n    ThisExpression(thisPath: NodePath<ThisExpression>) {\n      result = true;\n      thisPath.stop();\n    },\n  });\n\n  return result;\n}\n\nfunction appendWorkletClassMarker(classBody: ClassBody) {\n  classBody.body.push(\n    classProperty(identifier('__workletClass'), booleanLiteral(true))\n  );\n}\n\nfunction dehoistCommonJSExports(program: Program) {\n  const statements = program.body;\n  let end = statements.length;\n  let current = 0;\n\n  while (current < end) {\n    const statement = statements[current];\n    if (!isCommonJSExport(statement)) {\n      current++;\n      continue;\n    }\n    const exportStatement = statements.splice(current, 1);\n    statements.push(...exportStatement);\n    // We just removed one element from non-processed part,\n    // so we need to decrement the end index but not the current index.\n    end--;\n  }\n}\n\nfunction isCommonJSExport(statement: Statement) {\n  return (\n    isExpressionStatement(statement) &&\n    isAssignmentExpression(statement.expression) &&\n    isMemberExpression(statement.expression.left) &&\n    isIdentifier(statement.expression.left.object) &&\n    statement.expression.left.object.name === 'exports'\n  );\n}\n", "import type { NodePath } from '@babel/core';\nimport type {\n  MemberExpression,\n  ObjectExpression,\n  JSXAttribute,\n  ObjectProperty,\n} from '@babel/types';\nimport {\n  callExpression,\n  arrowFunctionExpression,\n  isArrayExpression,\n  isJSXExpressionContainer,\n  identifier,\n  stringLiteral,\n  expressionStatement,\n  memberExpression,\n  returnStatement,\n  blockStatement,\n  isIdentifier,\n} from '@babel/types';\nimport { isRelease } from './utils';\nimport type { ReanimatedPluginPass } from './types';\nimport { strict as assert } from 'assert';\n\nfunction generateInlineStylesWarning(path: NodePath<MemberExpression>) {\n  // replaces `sharedvalue.value` with `(()=>{console.warn(require('react-native-reanimated').getUseOfValueInStyleWarning());return sharedvalue.value;})()`\n  return callExpression(\n    arrowFunctionExpression(\n      [],\n      blockStatement([\n        expressionStatement(\n          callExpression(\n            memberExpression(identifier('console'), identifier('warn')),\n            [\n              callExpression(\n                memberExpression(\n                  callExpression(identifier('require'), [\n                    stringLiteral('react-native-reanimated'),\n                  ]),\n                  identifier('getUseOfValueInStyleWarning')\n                ),\n                []\n              ),\n            ]\n          )\n        ),\n        returnStatement(path.node),\n      ])\n    ),\n    []\n  );\n}\n\nfunction processPropertyValueForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  // if it's something like object.value then raise a warning\n  if (path.isMemberExpression() && isIdentifier(path.node.property)) {\n    if (path.node.property.name === 'value') {\n      path.replaceWith(generateInlineStylesWarning(path));\n    }\n  }\n}\n\nfunction processTransformPropertyForInlineStylesWarning(\n  path: NodePath<ObjectProperty['value']>\n) {\n  if (isArrayExpression(path.node)) {\n    const elements = path.get('elements');\n    assert(\n      Array.isArray(elements),\n      '[Reanimated] `elements` should be an array.'\n    );\n    for (const element of elements) {\n      if (element.isObjectExpression()) {\n        processStyleObjectForInlineStylesWarning(element);\n      }\n    }\n  }\n}\n\nfunction processStyleObjectForInlineStylesWarning(\n  path: NodePath<ObjectExpression>\n) {\n  const properties = path.get('properties');\n  for (const property of properties) {\n    if (property.isObjectProperty()) {\n      const value = property.get('value');\n      if (\n        isIdentifier(property.node.key) &&\n        property.node.key.name === 'transform'\n      ) {\n        processTransformPropertyForInlineStylesWarning(value);\n      } else {\n        processPropertyValueForInlineStylesWarning(value);\n      }\n    }\n  }\n}\n\nexport function processInlineStylesWarning(\n  path: NodePath<JSXAttribute>,\n  state: ReanimatedPluginPass\n) {\n  if (isRelease()) {\n    return;\n  }\n  if (state.opts.disableInlineStylesWarning) {\n    return;\n  }\n  if (path.node.name.name !== 'style') {\n    return;\n  }\n  if (!isJSXExpressionContainer(path.node.value)) {\n    return;\n  }\n\n  const expression = path.get('value').get('expression');\n  // style={[{...}, {...}]}\n  assert(\n    !Array.isArray(expression),\n    '[Reanimated] `expression` should not be an array.'\n  );\n  if (expression.isArrayExpression()) {\n    const elements = expression.get('elements');\n    assert(\n      Array.isArray(elements),\n      '[Reanimated] `elements` should be an array.'\n    );\n    for (const element of elements) {\n      if (element.isObjectExpression()) {\n        processStyleObjectForInlineStylesWarning(element);\n      }\n    }\n  }\n  // style={{...}}\n  else if (expression.isObjectExpression()) {\n    processStyleObjectForInlineStylesWarning(expression);\n  }\n}\n", "import type { NodePath } from '@babel/core';\nimport { booleanLiteral, isIdentifier } from '@babel/types';\nimport type { CallExpression } from '@babel/types';\n\nexport function substituteWebCallExpression(path: NodePath<CallExpression>) {\n  const callee = path.node.callee;\n  if (isIdentifier(callee)) {\n    const name = callee.name;\n    if (name === 'isWeb' || name === 'shouldBeUseWeb') {\n      path.replaceWith(booleanLiteral(true));\n    }\n  }\n}\n", "import type { NodePath } from '@babel/core';\nimport { transformSync } from '@babel/core';\nimport generate from '@babel/generator';\nimport traverse from '@babel/traverse';\nimport type {\n  File as BabelFile,\n  CallExpression,\n  ClassBody,\n  ClassDeclaration,\n  FunctionDeclaration,\n  Identifier,\n  Program,\n  Statement,\n  VariableDeclaration,\n} from '@babel/types';\nimport {\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  functionDeclaration,\n  functionExpression,\n  identifier,\n  isClassProperty,\n  isFunctionDeclaration,\n  isIdentifier,\n  isVariableDeclaration,\n  memberExpression,\n  returnStatement,\n  variableDeclaration,\n  variableDeclarator,\n} from '@babel/types';\nimport { strict as assert } from 'assert';\nimport type { ReanimatedPluginPass } from './types';\nimport { workletClassFactorySuffix } from './types';\nimport { replaceWithFactoryCall } from './utils';\n\nconst classWorkletMarker = '__workletClass';\n\nexport function processIfWorkletClass(\n  classPath: NodePath<ClassDeclaration>,\n  state: ReanimatedPluginPass\n): boolean {\n  if (!classPath.node.id) {\n    // We don't support unnamed classes yet.\n    return false;\n  }\n\n  if (!hasWorkletClassMarker(classPath.node.body)) {\n    return false;\n  }\n\n  removeWorkletClassMarker(classPath.node.body);\n\n  processClass(classPath, state);\n\n  return true;\n}\n\nfunction processClass(\n  classPath: NodePath<ClassDeclaration>,\n  state: ReanimatedPluginPass\n) {\n  assert(classPath.node.id);\n  const className = classPath.node.id.name;\n\n  const polyfilledClassAst = getPolyfilledAst(classPath.node, state);\n\n  sortPolyfills(polyfilledClassAst);\n\n  appendWorkletDirectiveToPolyfills(polyfilledClassAst.program.body);\n\n  replaceClassDeclarationWithFactoryAndCall(\n    polyfilledClassAst.program.body,\n    className\n  );\n\n  polyfilledClassAst.program.body.push(returnStatement(identifier(className)));\n\n  const factoryFactory = functionExpression(\n    null,\n    [],\n    blockStatement([...polyfilledClassAst.program.body])\n  );\n\n  const factoryCall = callExpression(factoryFactory, []);\n\n  replaceWithFactoryCall(classPath, className, factoryCall);\n}\n\nfunction getPolyfilledAst(\n  classNode: ClassDeclaration,\n  state: ReanimatedPluginPass\n) {\n  const classCode = generate(classNode).code;\n\n  const classWithPolyfills = transformSync(classCode, {\n    plugins: [\n      '@babel/plugin-transform-class-properties',\n      '@babel/plugin-transform-classes',\n      '@babel/plugin-transform-unicode-regex',\n    ],\n    filename: state.file.opts.filename,\n    ast: true,\n    babelrc: false,\n    configFile: false,\n  });\n\n  assert(classWithPolyfills && classWithPolyfills.ast);\n\n  return classWithPolyfills.ast;\n}\n\nfunction appendWorkletDirectiveToPolyfills(statements: Statement[]) {\n  statements.forEach((statement) => {\n    if (isFunctionDeclaration(statement)) {\n      const workletDirective = directive(directiveLiteral('worklet'));\n      statement.body.directives.push(workletDirective);\n    }\n  });\n}\n\n/**\n * Replaces\n *\n * ```ts\n * const Clazz = ...;\n * ```\n *\n * With\n *\n * ```ts\n * const Clazz__classFactory = ...;\n * const Clazz = Clazz__classFactory();\n * ```\n */\nfunction replaceClassDeclarationWithFactoryAndCall(\n  statements: Statement[],\n  className: string\n) {\n  const classFactoryName = className + workletClassFactorySuffix;\n\n  const classDeclarationIndex = getPolyfilledClassDeclarationIndex(\n    statements,\n    className\n  );\n\n  const classDeclarationToReplace = statements[\n    classDeclarationIndex\n  ] as VariableDeclaration;\n\n  const classDeclarationInit = classDeclarationToReplace.declarations[0]\n    .init as CallExpression;\n\n  const classFactoryDeclaration = functionDeclaration(\n    identifier(classFactoryName),\n    [],\n    blockStatement(\n      [\n        variableDeclaration('const', [\n          variableDeclarator(identifier(className), classDeclarationInit),\n        ]),\n        expressionStatement(\n          assignmentExpression(\n            '=',\n            memberExpression(\n              identifier(className),\n              identifier(classFactoryName)\n            ),\n            identifier(classFactoryName)\n          )\n        ),\n        returnStatement(identifier(className)),\n      ],\n      [directive(directiveLiteral('worklet'))]\n    )\n  );\n\n  const newClassDeclaration = variableDeclaration('const', [\n    variableDeclarator(\n      identifier(className),\n      callExpression(identifier(classFactoryName), [])\n    ),\n  ]);\n\n  statements.splice(\n    classDeclarationIndex,\n    1,\n    classFactoryDeclaration,\n    newClassDeclaration\n  );\n}\n\nfunction getPolyfilledClassDeclarationIndex(\n  statements: Statement[],\n  className: string\n) {\n  const index = statements.findIndex(\n    (statement) =>\n      isVariableDeclaration(statement) &&\n      statement.declarations.some(\n        (declaration) =>\n          isIdentifier(declaration.id) && declaration.id.name === className\n      )\n  );\n  assert(index >= 0);\n  return index;\n}\n\nfunction hasWorkletClassMarker(classBody: ClassBody) {\n  return classBody.body.some(\n    (statement) =>\n      isClassProperty(statement) &&\n      isIdentifier(statement.key) &&\n      statement.key.name === classWorkletMarker\n  );\n}\n\nfunction removeWorkletClassMarker(classBody: ClassBody) {\n  classBody.body = classBody.body.filter(\n    (statement) =>\n      !isClassProperty(statement) ||\n      !isIdentifier(statement.key) ||\n      statement.key.name !== classWorkletMarker\n  );\n}\n\nfunction sortPolyfills(ast: BabelFile) {\n  const toSort = getPolyfillsToSort(ast);\n\n  const sorted = topoSort(toSort);\n\n  const toSortIndices = toSort.map((element) => element.index);\n  const sortedIndices = sorted.map((element) => element.index);\n  const statements = ast.program.body;\n  const oldStatements = [...statements];\n\n  for (let i = 0; i < toSort.length; i++) {\n    const sourceIndex = sortedIndices[i];\n    const targetIndex = toSortIndices[i];\n    const source = oldStatements[sourceIndex];\n    statements[targetIndex] = source;\n  }\n}\n\nfunction getPolyfillsToSort(ast: BabelFile): Polyfill[] {\n  const polyfills: Polyfill[] = [];\n\n  traverse(ast, {\n    Program: {\n      enter: (functionPath: NodePath<Program>) => {\n        const statements = functionPath.get('body');\n        statements.forEach((statement, index) => {\n          const bindingIdentifiers = statement.getBindingIdentifiers();\n          // Polyfills are prepended as FunctionDeclarations.\n          if (!statement.isFunctionDeclaration() || !statement.node.id?.name) {\n            return;\n          }\n\n          const element: Polyfill = {\n            name: statement.node.id.name,\n            index,\n            dependencies: new Set(),\n          };\n          polyfills.push(element);\n          statement.traverse({\n            Identifier(path: NodePath<Identifier>) {\n              if (isOutsideDependency(path, bindingIdentifiers, statement)) {\n                element.dependencies.add(path.node.name);\n              }\n            },\n          });\n        });\n      },\n    },\n  });\n\n  return polyfills;\n}\n\nfunction topoSort(toSort: Polyfill[]): Polyfill[] {\n  const sorted: Polyfill[] = [];\n  const stack: Set<string> = new Set();\n  for (const element of toSort) {\n    recursiveTopoSort(element, toSort, sorted, stack);\n  }\n  return sorted;\n}\n\nfunction recursiveTopoSort(\n  current: Polyfill,\n  toSort: Polyfill[],\n  sorted: Polyfill[],\n  stack: Set<string>\n) {\n  if (stack.has(current.name)) {\n    throw new Error('Cycle detected. This should never happen.');\n  }\n  if (sorted.find((element) => element.name === current.name)) {\n    return;\n  }\n  stack.add(current.name);\n  for (const dependency of current.dependencies) {\n    if (!sorted.find((element) => element.name === dependency)) {\n      const next = toSort.find((element) => element.name === dependency);\n      assert(next);\n\n      recursiveTopoSort(next, toSort, sorted, stack);\n    }\n  }\n  sorted.push(current);\n  stack.delete(current.name);\n}\n\n/**\n * Checks if an identifier is a reference to an outside dependency. The\n * condition was made by trial and error.\n */\nfunction isOutsideDependency(\n  identifierPath: NodePath<Identifier>,\n  bindingIdentifiers: Record<string, Identifier>,\n  functionPath: NodePath<FunctionDeclaration>\n): boolean {\n  return (\n    // We don't care about identifiers that were just declared.\n    identifierPath.isReferencedIdentifier() &&\n    // We don't care about identifiers that are bound in the scope.\n    !(identifierPath.node.name in bindingIdentifiers) &&\n    // This I don't exactly understand, but the function identifier itself isn't in `bindingIdentifiers`,\n    // but it return true on `hasOwnBinding`.\n    !functionPath.scope.hasOwnBinding(identifierPath.node.name) &&\n    // `hasReference` returns true for global identifiers, like `Object`,\n    // we don't want to include those.\n    functionPath.scope.hasReference(identifierPath.node.name)\n  );\n}\n\ntype Polyfill = {\n  name: string;\n  index: number;\n  dependencies: Set<string>;\n};\n", "import type { NodePath, PluginItem } from '@babel/core';\nimport type {\n  CallExpression,\n  ClassDeclaration,\n  JSXAttribute,\n  ObjectExpression,\n  Program,\n} from '@babel/types';\nimport {\n  processCalleesAutoworkletizableCallbacks,\n  processIfAutoworkletizableCallback,\n} from './autoworkletization';\nimport { processIfWorkletContextObject } from './contextObject';\nimport { processIfWorkletFile } from './file';\nimport { initializeGlobals } from './globals';\nimport { processInlineStylesWarning } from './inlineStylesWarning';\nimport type { ReanimatedPluginPass } from './types';\nimport { WorkletizableFunction } from './types';\nimport { addCustomGlobals } from './utils';\nimport { substituteWebCallExpression } from './webOptimization';\nimport { processIfWithWorkletDirective } from './workletSubstitution';\nimport { processIfWorkletClass } from './class';\n\nmodule.exports = function (): PluginItem {\n  function runWithTaggedExceptions(fun: () => void) {\n    try {\n      fun();\n    } catch (e) {\n      throw new Error(`[Reanimated] Babel plugin exception: ${e as string}`);\n    }\n  }\n\n  return {\n    pre(state: ReanimatedPluginPass) {\n      runWithTaggedExceptions(() => {\n        // Initialize worklet number.\n        state.workletNumber = 1;\n        initializeGlobals();\n        addCustomGlobals.call(this);\n      });\n    },\n    visitor: {\n      CallExpression: {\n        enter(path: NodePath<CallExpression>, state: ReanimatedPluginPass) {\n          runWithTaggedExceptions(() => {\n            processCalleesAutoworkletizableCallbacks(path, state);\n            if (state.opts.substituteWebPlatformChecks) {\n              substituteWebCallExpression(path);\n            }\n          });\n        },\n      },\n      [WorkletizableFunction]: {\n        enter(\n          path: NodePath<WorkletizableFunction>,\n          state: ReanimatedPluginPass\n        ) {\n          runWithTaggedExceptions(() => {\n            processIfWithWorkletDirective(path, state) ||\n              processIfAutoworkletizableCallback(path, state);\n          });\n        },\n      },\n      ObjectExpression: {\n        enter(path: NodePath<ObjectExpression>, state: ReanimatedPluginPass) {\n          runWithTaggedExceptions(() => {\n            processIfWorkletContextObject(path, state);\n          });\n        },\n      },\n      ClassDeclaration: {\n        enter(path: NodePath<ClassDeclaration>, state: ReanimatedPluginPass) {\n          runWithTaggedExceptions(() => {\n            processIfWorkletClass(path, state);\n          });\n        },\n      },\n      Program: {\n        enter(path: NodePath<Program>, state: ReanimatedPluginPass) {\n          runWithTaggedExceptions(() => {\n            // Reset worklet number.\n            state.workletNumber = 1;\n            processIfWorkletFile(path, state);\n          });\n        },\n      },\n      JSXAttribute: {\n        enter(path: NodePath<JSXAttribute>, state: ReanimatedPluginPass) {\n          runWithTaggedExceptions(() =>\n            processInlineStylesWarning(path, state)\n          );\n        },\n      },\n    },\n  };\n};\n"],
  "mappings": "ozBASA,IAAAA,EAAA,QAAA,cAAA,EAoCaC,EAAA,sBACX,8EAIWA,EAAA,oBAAsB,mBAEnC,SAAgBC,GACdC,EAAuB,CAEvB,OACEA,EAAK,sBAAqB,GAC1BA,EAAK,qBAAoB,GACzBA,EAAK,0BAAyB,GAC9BA,EAAK,eAAc,CAEvB,CATAF,EAAA,4BAAAC,GAWA,SAAgBE,GACdC,EAAkC,CAElC,SACEL,EAAA,uBAAsBK,CAAI,MAC1BL,EAAA,sBAAqBK,CAAI,MACzBL,EAAA,2BAA0BK,CAAI,MAC9BL,EAAA,gBAAeK,CAAI,CAEvB,CATAJ,EAAA,4BAAAG,GAWA,SAAgBE,GACdH,EAAuB,CAEvB,OAAOA,EAAK,mBAAkB,CAChC,CAJAF,EAAA,0BAAAK,GAMA,SAAgBC,GACdF,EAAkC,CAElC,SAAOL,EAAA,oBAAmBK,CAAI,CAChC,CAJAJ,EAAA,0BAAAM,GAMaN,EAAA,0BAA4B,mJCtFzC,IAAMO,GAAyB,CAO7B,aACA,WACA,MACA,YAGA,OACA,WACA,QACA,aACA,WACA,YACA,qBACA,YACA,qBACA,SACA,WAGA,SACA,WACA,UACA,SAGA,QACA,iBACA,YACA,aACA,iBACA,cACA,YACA,WACA,gBAGA,SACA,SACA,OACA,OAGA,SACA,SAGA,QACA,YACA,aACA,oBACA,aACA,cACA,aACA,cACA,gBACA,iBACA,eACA,eAGA,MACA,MACA,UACA,UAGA,cACA,oBACA,WACA,UACA,OAGA,UACA,uBAGA,WACA,gBACA,UACA,oBACA,yBACA,YACA,iBACA,gBAGA,UACA,QAGA,OAGA,OACA,OACA,SACA,SACA,aACA,UACA,cACA,iBACA,wBACA,eACA,YAGA,iBAGA,WACA,kBACA,2BAGA,eACA,aACA,6BACA,yBACA,4BACA,kBACA,YACA,kBACA,UACA,kBACA,oBACA,kBACA,eACA,iBACA,eACA,iBACA,QAWIC,GAAoC,CAExC,aACA,OACA,YACA,4BACA,8BACA,qBACA,sBACA,oBACA,qBACA,2BACA,gBACA,iBACA,iBACA,wBACA,yBACA,mBACA,uBACA,kBACA,gBACA,0BAGWC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,EAAI,OAAO,QAAQ,GAChCN,GAA6B,IAAIM,EAAI,OAAO,SAAS,IAAI,CAE7D,kHChJA,IAAAG,EAAA,QAAA,cAAA,EASMC,GAAsB,IAAI,IAAI,CAClC,WACA,eACA,eACA,gBACA,aACA,YACA,gBACA,gBACA,iBACA,cACA,SACA,aACA,aACA,cACA,WACA,UACA,cACA,cACA,eACA,YACA,cACA,cACA,cACA,YACA,cACA,eACA,eACA,eACA,eACA,aACA,eACA,gBACA,mBACA,oBACA,oBACA,qBACA,aACA,cACA,aACA,cACA,cACA,eACA,mBACA,oBACA,iBACA,kBACA,oBACA,qBACA,kBACA,mBACA,cACA,cACA,eACA,YACA,eACA,eACA,gBACA,aACA,aACA,aACA,cACA,cACA,SACA,aACA,iBACA,eACA,aACA,cACA,eACA,WACA,UACA,cACA,kBACA,gBACA,cACA,eACA,gBACA,YACD,EAEKC,GAAoB,IAAI,IAAI,CAChC,SACA,mBACA,sBACA,mBACA,oBACA,mBACA,sBACD,EAEKC,GAAmB,IAAI,IAAI,CAC/B,GAAGF,GACH,GAAGC,GACJ,EAEKE,GAAiC,IAAI,IAAI,CAC7C,QACA,WACA,QACA,cACA,cACA,WACA,mBACD,EAEKC,GAAoC,IAAI,IAAI,CAChD,SACA,SACA,YACA,UACA,OACA,YACA,oBACA,4BACA,qBACA,oBACA,wBACD,EAEKC,GAAoC,IAAI,IAAI,CAChD,UACA,UACA,cACA,eACA,WACA,UACA,UACD,EAEKC,GAAmC,IAAI,IAAI,CAC/C,GAAGH,GACH,GAAGC,GACH,GAAGC,GACJ,EAEKE,GAA4B,IAAI,IAAI,CAAC,cAAc,CAAC,EAE1D,SAAgBC,GACdC,EAAqC,CAErC,SACEV,EAAA,kBAAiBU,EAAK,MAAM,MAC5BV,EAAA,cAAaU,EAAK,OAAO,MAAM,GAC/BC,GAAgCD,EAAK,OAAO,MAAM,CAEtD,CARAE,EAAA,0BAAAH,GAUA,SAASE,GAAgCE,EAAe,CACtD,SACEb,EAAA,oBAAmBa,CAAG,MACtBb,EAAA,cAAaa,EAAI,QAAQ,GACzBL,GAA0B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",
  "names": ["types_1", "exports", "isWorkletizableFunctionPath", "path", "isWorkletizableFunctionNode", "node", "isWorkletizableObjectPath", "isWorkletizableObjectNode", "notCapturedIdentifiers", "notCapturedIdentifiers_DEPRECATED", "exports", "initializeGlobals", "types_1", "globals_1", "isRelease", "pattern", "_a", "_b", "exports", "addCustomGlobals", "name", "replaceWithFactoryCall", "toReplace", "factoryCall", "needsDeclaration", "replacement", "nodePath", "core_1", "generator_1", "__importDefault", "types_1", "assert_1", "convertSourceMap", "__importStar", "fs", "types_2", "utils_1", "MOCK_SOURCE_MAP", "buildWorkletString", "fun", "state", "closureVariables", "workletName", "inputMap", "restoreRecursiveCalls", "draftExpression", "obj", "expression", "parsedClasses", "path", "constructorName", "variable", "index", "workletClassFactoryName", "workletFunction", "code", "includeSourceMap", "sourceFile", "transformed", "prependClosureVariablesIfNecessary", "sourceMap", "shouldMockSourceMap", "exports", "file", "newName", "oldName", "prependClosure", "closureDeclaration", "prependRecursiveDeclaration", "_a", "core_1", "generator_1", "__importDefault", "types_1", "assert_1", "path_1", "globals_1", "types_2", "utils_1", "workletStringCode_1", "REAL_VERSION", "MOCK_VERSION", "workletStringTransformPresets", "workletStringTransformPlugins", "makeWorkletFactory", "fun", "state", "removeWorkletDirective", "codeObject", "transformed", "variables", "makeArrayFromCapturedBindings", "clone", "funExpression", "workletName", "reactName", "makeWorkletName", "funString", "sourceMapString", "workletHash", "hash", "lineOffset", "pathForStringDefinitions", "path", "_a", "_b", "initDataId", "initDataObjectExpression", "location", "shouldMockVersion", "shouldIncludeInitData", "statements", "variable", "exports", "str", "i", "hash1", "hash2", "char", "source", "filepath", "splitFilepath", "nodeModulesIndex", "suffix", "ast", "closure", "isLocationAssignedMap", "name", "parentNode", "currentScope", "node", "types_1", "workletFactory_1", "makeWorkletFactoryCall", "path", "state", "workletFactory", "workletFactoryCall", "addStackTraceDataToWorkletFactory", "exports", "originalWorkletLocation", "types_1", "types_2", "utils_1", "workletFactoryCall_1", "processIfWithWorkletDirective", "path", "state", "hasWorkletDirective", "processWorklet", "exports", "subPath", "passedState", "workletFactoryCall", "substituteWorkletWithWorkletFactoryCall", "directives", "directive", "substituteObjectMethodWithObjectProperty", "name", "_a", "replacement", "types_1", "gestureHandlerGestureObjects", "gestureHandlerBuilderMethods", "isGestureHandlerEventCallback", "path", "isGestureObjectEventCallbackMethod", "exports", "exp", "containsGestureObject", "isGestureObject", "types_1", "EntryExitAnimations", "LayoutTransitions", "LayoutAnimations", "BaseAnimationsChainableMethods", "ComplexAnimationsChainableMethods", "DefaultTransitionChainableMethods", "LayoutAnimationsChainableMethods", "LayoutAnimationsCallbacks", "isLayoutAnimationCallback", "path", "isLayoutAnimationCallbackMethod", "exports", "exp", "isLayoutAnimationsChainableOrNewOperator", "types_1", "findReferencedWorklet", "workletIdentifier", "acceptWorkletizableFunction", "acceptObject", "workletName", "workletBinding", "findReferencedWorkletFromVariableDeclarator", "findReferencedWorkletFromAssignmentExpression", "exports", "workletDeclaration", "worklet", "constantViolation", "workletDefinition", "types_1", "workletSubstitution_1", "processWorkletizableObject", "path", "state", "properties", "property", "value", "exports", "types_1", "types_2", "workletSubstitution_1", "gestureHandlerAutoworkletization_1", "layoutAnimationAutoworkletization_1", "referencedWorklets_1", "objectWorklets_1", "objectHooks", "functionHooks", "functionArgsToWorkletize", "processIfAutoworkletizableCallback", "path", "state", "exports", "processCalleesAutoworkletizableCallbacks", "callee", "name", "acceptWorkletizableFunction", "acceptObject", "argIndices", "args", "_", "index", "processArgs", "arg", "maybeWorklet", "findWorklet", "types_1", "exports", "processIfWorkletContextObject", "path", "_state", "isContextObject", "removeContextObjectMarker", "processWorkletContextObject", "objectExpression", "property", "workletObjectFactory", "types_1", "types_2", "contextObject_1", "processIfWorkletFile", "path", "_state", "functionDirective", "processWorkletFile", "exports", "programPath", "statements", "dehoistCommonJSExports", "statement", "candidatePath", "getCandidate", "processWorkletizableEntity", "statementPath", "nodePath", "replaceImplicitReturnWithBlock", "appendWorkletDirective", "isImplicitContextObject", "appendWorkletContextObjectMarker", "processWorkletAggregator", "processVariableDeclaration", "appendWorkletClassMarker", "variableDeclarationPath", "declaration", "initPath", "objectPath", "property", "valuePath", "node", "objectExpression", "value", "propertyPath", "hasThisExpression", "result", "thisPath", "classBody", "program", "end", "current", "isCommonJSExport", "exportStatement", "types_1", "utils_1", "assert_1", "generateInlineStylesWarning", "path", "processPropertyValueForInlineStylesWarning", "processTransformPropertyForInlineStylesWarning", "elements", "element", "processStyleObjectForInlineStylesWarning", "properties", "property", "value", "processInlineStylesWarning", "state", "expression", "exports", "types_1", "substituteWebCallExpression", "path", "callee", "name", "exports", "core_1", "generator_1", "__importDefault", "traverse_1", "types_1", "assert_1", "types_2", "utils_1", "classWorkletMarker", "processIfWorkletClass", "classPath", "state", "hasWorkletClassMarker", "removeWorkletClassMarker", "processClass", "exports", "className", "polyfilledClassAst", "getPolyfilledAst", "sortPolyfills", "appendWorkletDirectiveToPolyfills", "replaceClassDeclarationWithFactoryAndCall", "factoryFactory", "factoryCall", "classNode", "classCode", "classWithPolyfills", "statements", "statement", "workletDirective", "classFactoryName", "classDeclarationIndex", "getPolyfilledClassDeclarationIndex", "classDeclarationInit", "classFactoryDeclaration", "newClassDeclaration", "index", "declaration", "classBody", "ast", "toSort", "getPolyfillsToSort", "sorted", "topoSort", "toSortIndices", "element", "sortedIndices", "oldStatements", "i", "sourceIndex", "targetIndex", "source", "polyfills", "functionPath", "bindingIdentifiers", "_a", "path", "isOutsideDependency", "stack", "recursiveTopoSort", "current", "dependency", "next", "identifierPath", "autoworkletization_1", "contextObject_1", "file_1", "globals_1", "inlineStylesWarning_1", "types_1", "utils_1", "webOptimization_1", "workletSubstitution_1", "class_1", "runWithTaggedExceptions", "fun", "e", "state", "path"]
}
